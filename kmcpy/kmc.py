"""
Function and classes for running kMC

Author: Zeyu Deng
Email: dengzeyu@gmail.com
"""

import random
import numpy as np
from pymatgen.core import Structure,Lattice
from numba.typed import List
from kmcpy.external.pymatgen_structure import Structure
import numpy as np
import pandas as pd
from copy import copy
import json
from kmcpy.model import LocalClusterExpansion
from kmcpy.tracker import Tracker
from kmcpy.event import Event
from kmcpy.io import convert
class KMC:
    """
    main function of kinetic monte carlo
    """
    def __init__(self,**kwargs):
        if "api" in kwargs:
            self.api=kwargs["api"]
        else:
            self.api=1
        pass

    def initialization(self,**kwargs):
        """initialization function with capability on dealing with multiple versions of input
        
        This function try to grab the api keyword in kwargs. If fail, then set api=1
        
        Then it will call the initialization function of specified version, pass all kwargs to the initialization1 or initialization2... except the api kwargs (of course)
        
        Notice that the initialization functions have default value for the input! It is recommended to set the parameters explicitly. It is better to overdefining the parameters rather than underdefining parameters. Do not worry passing too much argument. For example, pass immutable_sites=["Zr","O"] to initialization1, The initialization1 will receive it as kwargs, do nothing on it and forget it.
        
        Raises:
            NotImplementedError: if the api parameter is strange

        Returns:
            list: list of kmc.event.Event object, generated by the different version of initialization function
        """
        if "api" in kwargs:
            self.api=kwargs["api"]

            

        return self.initialization3(**kwargs)

 
    def initialization3(self,
    occ=np.array([-1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1]),
    prim_fname='./inputs/EntryWithCollCode15546_Na4Zr2Si3O12_573K.cif',
    fitting_results='./inputs/fitting_results.json',
    fitting_results_site='./inputs/fitting_results_site.json',
    event_fname="./inputs/events.json",
    supercell_shape=[2,1,1],
    v=5000000000000,
    T=298,
    lce_fname="./inputs/lce.json",
    lce_site_fname="./inputs/lce_site.json",
    immutable_sites=["Zr","O"],
    convert_to_primitive_cell=False,
    **kwargs):
        """
        XIEWEIHANG 220608
        
        the 3rd version of initialization process. 
        
        
        Validate Args:
            occ (np.array, optional): this is the chebyshev occupation of sites, representing the initial state of the model. Defaults to np.array([-1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1]).
            prim_fname (str, optional): the primitive cell of the input structure. Defaults to './inputs/prim.cif'.
            fitting_results (str, optional): This is the fitting results matrix, related to the activation barrier E_kra. Defaults to './inputs/fitting_results.json'.
            fitting_results_site (str, optional):  This is the fitting results matrix, related to the site energy E_end Defaults to './inputs/fitting_results_site.json'.
            event_fname (str, optional): record all possible event. Defaults to "./inputs/events.json".
            supercell_shape (list, optional): _description_. Defaults to [2,1,1].
            v (int, optional): vibration frequency. Defaults to 5000000000000.
            T (int, optional): temperature. Defaults to 298.
            lce_fname (str, optional): This contains all lce orbit related to the activation barrier E_kra. Defaults to "./inputs/lce.json".
            lce_site_fname (str, optional): This contains all lce orbit related to the activation barrier E_end. Defaults to "./inputs/lce_site.json".
            immutable_sites (list, optional):the sites that do not participate in the monte carlo process. For example,. in NaSICON, the Zr and O do not participate, the Na/Vac and P/S pairs are considered. Defaults to ["Zr","O"].
            verbose (bool, optional): trying to enable the verbose output. Defaults to False.
            convert_to_primitive_cell(bool): whether or not convert input cif file to primitive cell
        Returns:
            list: a list of kmc.event.Event object
        """



        print('Initializing kMC calculations with pirm.cif at',prim_fname,'...')
        self.structure=Structure.from_cif(prim_fname,primitive=convert_to_primitive_cell)
        supercell_shape_matrix = np.diag(supercell_shape)
        print('Supercell Shape:\n',supercell_shape_matrix)

        print('Converting to the supercell ...')
        print("removing the immutable sites:",immutable_sites)
        self.structure.remove_species(immutable_sites)
        self.structure.make_supercell(supercell_shape_matrix)
        
        print('Loading fitting results: E_kra ...')
        fitting_results = pd.read_json(fitting_results,orient='index').sort_values(by=['time_stamp'],ascending=False).iloc[0]
        self.keci = fitting_results.keci
        self.empty_cluster = fitting_results.empty_cluster

        print('Loading fitting results: site energy ...')
        fitting_results_site = pd.read_json(fitting_results_site,orient='index').sort_values(by=['time_stamp'],ascending=False).iloc[0]
        self.keci_site = fitting_results_site.keci
        self.empty_cluster_site = fitting_results_site.empty_cluster

        print('Loading occupation:',occ)
        self.occ_global = copy(occ)

        print('Loading LCE models from:',lce_fname,'and',lce_site_fname)
        local_cluster_expansion = LocalClusterExpansion.from_json(lce_fname)
        local_cluster_expansion_site = LocalClusterExpansion.from_json(lce_site_fname)
        
        # sublattice_indices are the orbits in table S3 of support information
        # Convert them into Numba List for faster execution
        sublattice_indices = _convert_list(local_cluster_expansion.sublattice_indices)
        sublattice_indices_site = _convert_list(local_cluster_expansion_site.sublattice_indices)
        events_site_list = []
        
        print('Loading events from:',event_fname)
        with open(event_fname,'rb') as fhandle:
            events_dict = json.load(fhandle)
        
        print('Initializing correlation matrix and E_kra for all events ...')
        events = []
        for event_dict in events_dict:
            event = Event.from_dict(event_dict)
            event.set_sublattice_indices(sublattice_indices,sublattice_indices_site)
            event.initialize_corr()
            event.update_event(self.occ_global,v,T,self.keci,self.empty_cluster,self.keci_site,self.empty_cluster_site)
            events_site_list.append(event.local_env_indices_list)
            events.append(event)
            
        print('Initializing hopping probabilities ...')
        self.prob_list = [event.probability for event in events]
        self.prob_cum_list = np.cumsum(self.prob_list)
        

        print('Fitted time and error (LOOCV,RMS)')
        print(fitting_results.time,fitting_results.loocv,fitting_results.rmse)
        print('Fitted KECI and empty cluster E_kra')
        print(self.keci,self.empty_cluster)

        print('Fitted time and error (LOOCV,RMS) (site energy)')
        print(fitting_results_site.time,fitting_results_site.loocv,fitting_results_site.rmse)
        print('Fitted KECI and empty cluster (site energy or E_end)')
        print(self.keci_site,self.empty_cluster_site)
        print("Lists for each event",events_site_list)
        print("Hopping probabilities:",self.prob_list)
        print("Cumulative sum of hopping probabilities:",self.prob_cum_list)
        print("Parameters that are not used during the initialization process:",kwargs)
        print("API version:",self.api)
        return events
    
    def load_site_event_list(self,fname="../event_kernal.csv"):# workout the site_event_list -> site_event_list[site_index] will return a list of event index to update if a site_index is chosen
        print('Working at the site_event_list ...')

        print('Loading',fname)
        site_event_list = []
        with open(fname) as f:
            data = f.readlines()
        for x in data:
            if len(x.strip()) == 0:
                site_event_list.append([])
            else:
                site_event_list.append([int(y) for y in x.strip().split()])
        self.site_event_list =site_event_list

    def show_project_info(self):
        try:
            print('Probabilities:')
            print(self.prob_list)
            print('Cumultative probability list:')
            print(self.prob_cum_list/sum(self.prob_list))
        except:
            pass

    def propose(self,events,random_seed=123456,use_numpy_random_kernel=True,api=2,rng=np.random.default_rng(),**kwargs): # propose() will propose an event to be updated by update()
        """propose a new event to be updated by update()

        Args:
            events (list): list of event
            random_seed (int or bool, optional): random seed, if None, then no randomseed. This only make sense if use_numpy_random_kernel. Defaults to 114514.
            use_numpy_random_kernel (bool, optional): whether to Use numpy random number generator. Defaults to True.
            api (int, optional): api version. Usage of numpy random kernel is introduced since api=2. Defaults to 2.
            rng (np.random.generator object, optional): a random number generator object. Defaults to np.random.default_rng(). Theoratically this function will receive a random number generator object as a input

        Raises:
            NotImplementedError: for API=1, "propose" function will use the python internal random function. For API=2 and use_numpy_random_kernel=True," propose" function will use the numpy generator class to generate the random numbers. Other functions are not implemented.

        Returns:
            event and time_change: what event is chosed by the random, and the time for this event to occur
        """
        if (api==1) or (use_numpy_random_kernel is not True):

            random_seed = random.random()
            random_seed_2 = random.random()
            proposed_event_index = np.searchsorted(self.prob_cum_list/(self.prob_cum_list[-1]),random_seed,side='right')
            time_change = (-1.0/self.prob_cum_list[-1])*np.log(random_seed_2)

            event = events[proposed_event_index]

            return event, time_change
        elif api>=2 and use_numpy_random_kernel:

            

            random_seed = rng.random()
            random_seed_2 = rng.random()
            proposed_event_index = np.searchsorted(self.prob_cum_list/(self.prob_cum_list[-1]),random_seed,side='right')
            time_change = (-1.0/self.prob_cum_list[-1])*np.log(random_seed_2)

            event = events[proposed_event_index]

            return event, time_change
        else:
            raise NotImplementedError("debug information: api",api," \nusing numpy random number generator instead of random(bool):",use_numpy_random_kernel)    



    def update(self,event,events):
        self.occ_global[event.mobile_ion_specie_1_index]*=(-1)
        self.occ_global[event.mobile_ion_specie_2_index]*=(-1)
        events_to_be_updated = copy(self.site_event_list[event.mobile_ion_specie_2_index])# event_to_be_updated= list, include the indices, of the event that need to be updated. 
        for e_index in events_to_be_updated:
            events[e_index].update_event(self.occ_global,self.v,self.T,self.keci,self.empty_cluster,self.keci_site,self.empty_cluster_site)
            self.prob_list[e_index] = copy(events[e_index].probability)
        self.prob_cum_list = np.cumsum(self.prob_list)

    def run_from_database(self,verbose=False,**kwargs):

        return self.run3(**kwargs)           
            

    def run3(self,kmc_pass=1000,
    equ_pass=1,v=5000000000000,
    T=298,
    events="./inputs/events.json",
    comp=1,
    random_seed=114514,
    use_numpy_random_kernel=True,
    verbose=False,
    mobile_ion_specie='Na',
    q=1.0,
    dimension=3,
    structure_idx=1,
    elem_hop_distance=3.47782,
    **kwargs):
        """kmc main function version 3. Previous versions are removed for readability

        Args:
            kmc_pass (int, optional): number of pass to run. Defaults to 1000.
            equ_pass (int, optional): _description_. Defaults to 1.
            v (int, optional): refer to paper. Defaults to 5000000000000.
            T (int, optional): refer to paper, temperature. Defaults to 298.
            events (str, optional): path to event.json. Defaults to "./inputs/events.json".
            comp (int, optional): composition, refer to paper. Defaults to 1.
            random_seed (int, optional): random seed. Should only be provided when test the KMC function. IF not testing as developer ,strictly set this to None. Defaults to 114514.
            use_numpy_random_kernel (bool, optional): whether use numpy random kernel which enable manually assign the random seed. If not testing as a developer, strictly set this to False. Defaults to True.
            verbose (bool, optional): verbose output. Defaults to False.
            mobile_ion_specie (str, optional): mobile ion specie to track. Defaults to 'Na'.
            q (float, optional): charge of mobile ion specie. Defaults to 1.0.
            dimension (int, optional): dimension of diffusion. For LiCoO2 it is 2 (2D diffusion). for NaSICON it is 3. Defaults to 3.
            structure_idx (int, optional): structure index . Defaults to 1.
            elem_hop_distance (float, optional): the hopping distance for the mobile ion specie, for NasiCON, this is the distance between Na1 and nearest Na2 site, for LiCoO2, this is the distance between 2 Li site. Defaults to 3.47782.

        Returns:
            kmcpy.tracker.Tracker: return the tracker for testing unit to assert some functions.
        """
        api=3
        
        if use_numpy_random_kernel==True:
            self.rng=np.random.default_rng(seed=random_seed)
        else:
            self.rng=False
        
        print('Simulation condition: v =',v,'T = ',T)
        self.v = v
        self.T = T
        pass_length = len([el.symbol for el in self.structure.species if mobile_ion_specie in el.symbol])
        print('============================================================')
        print('Start running kMC ... ')
        print('\nInitial occ_global, prob_list and prob_cum_list')
        print('Starting Equilbrium ...')
        for current_pass in np.arange(equ_pass):
            for this_kmc in np.arange(pass_length):
                event,time_change = self.propose(events,random_seed=random_seed,use_numpy_random_kernel=use_numpy_random_kernel,api=api,rng=self.rng,verbose=verbose)
                self.update(event,events)

        print('Start running kMC ...')
        tracker = Tracker(api=3)

        tracker.initialization(occ_initial=self.occ_global,structure=self.structure,T=self.T,v=self.v,q=q,mobile_ion_specie=mobile_ion_specie,dimension=dimension,elem_hop_distance=elem_hop_distance,**kwargs) #
        print('Pass\tTime\t\tMSD\t\tD_J\t\tD_tracer\tConductivity\tH_R\t\tf') # < ------- Change this please
        for current_pass in np.arange(kmc_pass):
            for this_kmc in np.arange(pass_length):
                event,time_change = self.propose(events,random_seed=random_seed,use_numpy_random_kernel=use_numpy_random_kernel,api=api,rng=self.rng,verbose=verbose) # < ------- Change this please
                tracker.update(event,self.occ_global,time_change)
                self.update(event,events)

            previous_conduct = tracker.summary(comp,current_pass)
            tracker.show_current_info(comp,current_pass)

        tracker.write_results(comp,structure_idx,current_pass,self.occ_global)
        if verbose:
            print("verbose information: kmc.KMC.run is called. API version 3")
        return tracker
                        

    # def run(self,kmc_pass,equ_pass,v,T,events):
    #     print('Simulation condition: v =',v,'T = ',T)
    #     self.v = v
    #     self.T = T
    #     pass_length = len([el.symbol for el in self.structure.species if 'Na' in el.symbol])
    #     print('============================================================')
    #     print('Start running kMC ... ')
    #     print('\nInitial occ_global, prob_list and prob_cum_list')
    #     print('Starting Equilbrium ...')
    #     for current_pass in np.arange(equ_pass):
    #         for this_kmc in np.arange(pass_length):
    #             event,time_change = self.propose(events)
    #             self.update(event,events)

    #     print('Start running kMC ...')
    #     tracker = Tracker()
    #     tracker.initialization(self.occ_global,self.structure,self.T,self.v)
    #     print('Pass\tTime\t\tMSD\t\tD_J\t\tD_tracer\tConductivity\tH_R\t\tf\t\tOccNa(1)\tOccNa(2)')
    #     for current_pass in np.arange(kmc_pass):
    #         for this_kmc in np.arange(pass_length):
    #             event,time_change = self.propose(events)
    #             tracker.update(event,self.occ_global,time_change)
    #             self.update(event,events)

    #         previous_conduct = tracker.summary(comp,current_pass)
    #         tracker.show_current_info(current_pass)

    #     tracker.write_results(None,None,current_pass,self.occ_global)

    def as_dict(self):
        d = {"@module":self.__class__.__module__,
        "@class": self.__class__.__name__,
        "structure":self.structure.as_dict(),
        "keci":self.keci,
        "empty_cluster":self.empty_cluster,
        "keci_site":self.keci_site,
        "empty_cluster_site":self.empty_cluster_site,
        "occ_global":self.occ_global}
        return d
    
    def to_json(self,fname):
        print('Saving:',fname)
        with open(fname,'w') as fhandle:
            d = self.as_dict()
            jsonStr = json.dumps(d,indent=4,default=convert) # to get rid of errors of int64
            fhandle.write(jsonStr)
    
    @classmethod
    def from_json(self,fname):
        print('Loading:',fname)
        with open(fname,'rb') as fhandle:
            objDict = json.load(fhandle)
        obj = KMC()
        obj.__dict__ = objDict
        print("load complete")
        return obj

def _convert_list(list_to_convert):
    converted_list = List([List(List(j) for j in i ) for i in list_to_convert])
    return converted_list

