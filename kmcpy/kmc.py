"""
Function and classes for running kMC

Author: Zeyu Deng
Email: dengzeyu@gmail.com
"""

import random
import numpy as np
from pymatgen.core import Structure,Lattice
from numba.typed import List
from kmcpy.external.pymatgen_structure import Structure
import numpy as np
import pandas as pd
from copy import copy
import json
from kmcpy.model import LocalClusterExpansion
from kmcpy.tracker import Tracker
from kmcpy.event import Event
from kmcpy.io import convert
class KMC:
    def __init__(self,**kwargs):
        if "api" in kwargs:
            self.api=kwargs["api"]
        else:
            self.api=1
        pass

    def initialization(self,**kwargs):
        """initialization function with capability on dealing with multiple versions of input
        
        This function try to grab the api keyword in kwargs. If fail, then set api=1
        
        Then it will call the initialization function of specified version, pass all kwargs to the initialization1 or initialization2... except the api kwargs (of course)
        
        Notice that the initialization functions have default value for the input! It is recommended to set the parameters explicitly. It is better to overdefining the parameters rather than underdefining parameters. Do not worry passing too much argument. For example, pass immutable_sites=["Zr","O"] to initialization1, The initialization1 will receive it as kwargs, do nothing on it and forget it.
        
        Raises:
            NotImplementedError: if the api parameter is strange

        Returns:
            list: list of kmc.event.Event object, generated by the different version of initialization function
        """
        if "api" in kwargs:
            self.api=kwargs["api"]

            
            
        if self.api==1:
            return self.initialization1(**kwargs)
        elif self.api==2:
            return self.initialization2(**kwargs)
        else:
            raise NotImplementedError("wrong API version")
    
    def initialization1(self,occ=np.array([-1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1]),prim_fname='./inputs/prim.json',fitting_results='./inputs/fitting_results.json',fitting_results_site='./inputs/fitting_results_site.json',event_fname="./inputs/events.json",supercell_shape=[2,1,1],v=5000000000000,T=298,lce_fname="./inputs/lce.json",lce_site_fname="./inputs/lce_site.json",**kwargs):
        """original api, as of 220303

        Returns:
            _type_: _description_
        """

        print('Initializing kMC calculations with pirm.json at',prim_fname,'...')
        with open(prim_fname,'r') as f:
            prim = json.load(f)
            prim_coords = [site['coordinate'] for site in prim['basis']]
            prim_specie_cases = [site['occupant_dof'] for site in prim['basis']]
            prim_lattice = Lattice(prim['lattice_vectors'])
            prim_species = [s[0] for s in prim_specie_cases]

        supercell_shape_matrix = np.diag(supercell_shape)
        print('Supercell Shape:\n',supercell_shape_matrix)
        self.structure = Structure(prim_lattice,prim_species,prim_coords)
        print('Converting supercell ...')
        self.structure.remove_species(['Zr','O'])
        self.structure.make_supercell(supercell_shape_matrix)
        print('Loading fitting results ...')
        fitting_results = pd.read_json(fitting_results,orient='index').sort_values(by=['time_stamp'],ascending=False).iloc[0]
        self.keci = fitting_results.keci
        self.empty_cluster = fitting_results.empty_cluster

        print('Loading fitting results (site energy) ...')
        fitting_results_site = pd.read_json(fitting_results_site,orient='index').sort_values(by=['time_stamp'],ascending=False).iloc[0]
        self.keci_site = fitting_results_site.keci
        self.empty_cluster_site = fitting_results_site.empty_cluster

        print('Loading occupation:',occ)
        self.occ_global = copy(occ)
        print('Fitted time and error (LOOCV,RMS)')
        print(fitting_results.time,fitting_results.loocv,fitting_results.rmse)
        print('Fitted KECI and empty cluster')
        print(self.keci,self.empty_cluster)

        print('Fitted time and error (LOOCV,RMS) (site energy)')
        print(fitting_results_site.time,fitting_results_site.loocv,fitting_results_site.rmse)
        print('Fitted KECI and empty cluster (site energy)')
        print(self.keci_site,self.empty_cluster_site)
        local_cluster_expansion = LocalClusterExpansion.from_json(lce_fname)
        local_cluster_expansion_site = LocalClusterExpansion.from_json(lce_site_fname)
        sublattice_indices = _convert_list(local_cluster_expansion.sublattice_indices)
        sublattice_indices_site = _convert_list(local_cluster_expansion_site.sublattice_indices)
        print('Initializing correlation matrix and ekra for all events ...')
        events_site_list = []
        
        print('Loading events from:',event_fname)
        with open(event_fname,'rb') as fhandle:
            events_dict = json.load(fhandle)
        
        events = []
        for event_dict in events_dict:
            event = Event.from_dict(event_dict)
            event.set_sublattice_indices(sublattice_indices,sublattice_indices_site)
            event.initialize_corr()
            event.update_event(self.occ_global,v,T,self.keci,self.empty_cluster,self.keci_site,self.empty_cluster_site)
            events_site_list.append(event.sorted_sublattice_indices)
            events.append(event)
            
        self.prob_list = [event.probability for event in events]
        self.prob_cum_list = np.cumsum(self.prob_list)
        return events
    
    def initialization2(self,occ=np.array([-1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1]),prim_fname='./inputs/EntryWithCollCode15546_Na4Zr2Si3O12_573K.cif',fitting_results='./inputs/fitting_results.json',fitting_results_site='./inputs/fitting_results_site.json',event_fname="./inputs/events.json",supercell_shape=[2,1,1],v=5000000000000,T=298,lce_fname="./inputs/lce.json",lce_site_fname="./inputs/lce_site.json",immutable_sites=["Zr","O"],verbose=False,convert_to_primitive_cell=False,**kwargs):
        """the 2nd version of initialization process. 
        
        
        Validate Args:
            occ (np.array, optional): this is the chebyshev occupation of sites, representing the initial state of the model. Defaults to np.array([-1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1]).
            prim_fname (str, optional): the primitive cell of the input structure. Defaults to './inputs/prim.cif'.
            fitting_results (str, optional): This is the fitting results matrix, related to the activation barrier E_kra. Defaults to './inputs/fitting_results.json'.
            fitting_results_site (str, optional):  This is the fitting results matrix, related to the site energy E_end Defaults to './inputs/fitting_results_site.json'.
            event_fname (str, optional): record all possible event. Defaults to "./inputs/events.json".
            supercell_shape (list, optional): _description_. Defaults to [2,1,1].
            v (int, optional): vibration frequency. Defaults to 5000000000000.
            T (int, optional): temperature. Defaults to 298.
            lce_fname (str, optional): This contains all lce orbit related to the activation barrier E_kra. Defaults to "./inputs/lce.json".
            lce_site_fname (str, optional): This contains all lce orbit related to the activation barrier E_end. Defaults to "./inputs/lce_site.json".
            immutable_sites (list, optional):the sites that do not participate in the monte carlo process. For example,. in NaSICON, the Zr and O do not participate, the Na/Vac and P/S pairs are considered. Defaults to ["Zr","O"].
            verbose (bool, optional): trying to enable the verbose output. Defaults to False.
            convert_to_primitive_cell(bool): whether or not convert input cif file to primitive cell

        Returns:
            list: a list of kmc.event.Event object
        """

        print('Initializing kMC calculations with pirm.cif at',prim_fname,'...')
        
        

        self.structure=Structure.from_cif(prim_fname,primitive=convert_to_primitive_cell)
            
            

        supercell_shape_matrix = np.diag(supercell_shape)
        print('Supercell Shape:\n',supercell_shape_matrix)

        
        print('Converting to the supercell ...')
        print("removing the immutable sites:",immutable_sites)
        self.structure.remove_species(immutable_sites)
        self.structure.make_supercell(supercell_shape_matrix)
        
        print('Loading fitting results E_kra...')
        fitting_results = pd.read_json(fitting_results,orient='index').sort_values(by=['time_stamp'],ascending=False).iloc[0]
        self.keci = fitting_results.keci
        self.empty_cluster = fitting_results.empty_cluster

        print('Loading fitting results (site energy or E_end) ...')
        fitting_results_site = pd.read_json(fitting_results_site,orient='index').sort_values(by=['time_stamp'],ascending=False).iloc[0]
        self.keci_site = fitting_results_site.keci
        self.empty_cluster_site = fitting_results_site.empty_cluster

        print('Loading occupation:',occ)
        self.occ_global = copy(occ)

        
        local_cluster_expansion = LocalClusterExpansion.from_json(lce_fname)
        local_cluster_expansion_site = LocalClusterExpansion.from_json(lce_site_fname)
        
        # sublattice_indices are the orbits in table S3 of support information
        sublattice_indices = _convert_list(local_cluster_expansion.sublattice_indices)
        sublattice_indices_site = _convert_list(local_cluster_expansion_site.sublattice_indices)
        print('Initializing correlation matrix and E_kra for all events ...')
        events_site_list = []
        
        print('Loading events from:',event_fname)
        with open(event_fname,'rb') as fhandle:
            events_dict = json.load(fhandle)
        
        events = []
        for event_dict in events_dict:
            event = Event.from_dict(event_dict)
            event.set_sublattice_indices(sublattice_indices,sublattice_indices_site)
            event.initialize_corr()
            event.update_event(self.occ_global,v,T,self.keci,self.empty_cluster,self.keci_site,self.empty_cluster_site)
            events_site_list.append(event.sorted_sublattice_indices)
            events.append(event)
            
    
            
        self.prob_list = [event.probability for event in events]
        self.prob_cum_list = np.cumsum(self.prob_list)
        

        
        
        if verbose:
            print('Fitted time and error (LOOCV,RMS)')
            print(fitting_results.time,fitting_results.loocv,fitting_results.rmse)
            print('Fitted KECI and empty cluster E_kra')
            print(self.keci,self.empty_cluster)

            print('Fitted time and error (LOOCV,RMS) (site energy)')
            print(fitting_results_site.time,fitting_results_site.loocv,fitting_results_site.rmse)
            print('Fitted KECI and empty cluster (site energy or E_end)')
            print(self.keci_site,self.empty_cluster_site)
            print("events_site_list",events_site_list)
            print("prob_list",self.prob_list)
            print("prob_cum_list",self.prob_cum_list)
            print("parameters that are not used during the initialization process:",kwargs)
            print("API version:",self.api)
            
        
        
        return events    
    

    def load_site_event_list(self,fname="../event_kernal.csv"):# workout the site_event_list -> site_event_list[site_index] will return a list of event index to update if a site_index is chosen
        print('Working at the site_event_list ...')

        print('Loading',fname)
        site_event_list = []
        with open(fname) as f:
            data = f.readlines()
        for x in data:
            if len(x.strip()) == 0:
                site_event_list.append([])
            else:
                site_event_list.append([int(y) for y in x.strip().split()])
        self.site_event_list =site_event_list

    def show_project_info(self):
        try:
            print('Probabilities:')
            print(self.prob_list)
            print('Cumultative probability list:')
            print(self.prob_cum_list/sum(self.prob_list))
        except:
            pass

    def propose(self,events,random_seed=123456,use_numpy_random_kernel=True,api=2,rng=np.random.default_rng(),**kwargs): # propose() will propose an event to be updated by update()
        """propose a new event to be updated by update()

        Args:
            events (list): list of event
            random_seed (int or bool, optional): random seed, if None, then no randomseed. This only make sense if use_numpy_random_kernel. Defaults to 114514.
            use_numpy_random_kernel (bool, optional): whether to Use numpy random number generator. Defaults to True.
            api (int, optional): api version. Usage of numpy random kernel is introduced since api=2. Defaults to 2.
            rng (np.random.generator object, optional): a random number generator object. Defaults to np.random.default_rng(). Theoratically this function will receive a random number generator object as a input

        Raises:
            NotImplementedError: for API=1, "propose" function will use the python internal random function. For API=2 and use_numpy_random_kernel=True," propose" function will use the numpy generator class to generate the random numbers. Other functions are not implemented.

        Returns:
            event and time_change: what event is chosed by the random, and the time for this event to occur
        """
        if (api==1) or (api==2 and (use_numpy_random_kernel is not True)):

            random_seed = random.random()
            random_seed_2 = random.random()
            proposed_event_index = np.searchsorted(self.prob_cum_list/(self.prob_cum_list[-1]),random_seed,side='right')
            time_change = (-1.0/self.prob_cum_list[-1])*np.log(random_seed_2)

            event = events[proposed_event_index]

            return event, time_change
        elif api==2 and use_numpy_random_kernel:

            

            random_seed = rng.random()
            random_seed_2 = rng.random()
            proposed_event_index = np.searchsorted(self.prob_cum_list/(self.prob_cum_list[-1]),random_seed,side='right')
            time_change = (-1.0/self.prob_cum_list[-1])*np.log(random_seed_2)

            event = events[proposed_event_index]

            return event, time_change
        else:
            raise NotImplementedError("debug information: api",api," \nusing numpy random number generator instead of random(bool):",use_numpy_random_kernel)    



    def update(self,event,events):
        self.occ_global[event.na1_index]*=(-1)
        self.occ_global[event.na2_index]*=(-1)
        events_to_be_updated = copy(self.site_event_list[event.na2_index])# event_to_be_updated= list, include the indices, of the event that need to be updated. 
        for e_index in events_to_be_updated:
            events[e_index].update_event(self.occ_global,self.v,self.T,self.keci,self.empty_cluster,self.keci_site,self.empty_cluster_site)
            self.prob_list[e_index] = copy(events[e_index].probability)
        self.prob_cum_list = np.cumsum(self.prob_list)

    def run_from_database(self,verbose=False,**kwargs):
        if "api" in kwargs:
            self.api=kwargs["api"]
        if verbose:
            print("Verbose output started:\nFunction: kmc.run_from_database.\n parameters received:",kwargs,"end of this verbose output")
        if self.api==1:
            self.run_from_database1(**kwargs)
        if self.api==2:
            self.run_from_database2(**kwargs)
            
            
    def run_from_database1(self,kmc_pass=1000,equ_pass=1,v=5000000000000,T=298,events="./inputs/events.json",comp=1,structure_idx=1,**kwargs):
        #api=1
        api=1
        print('Simulation condition: v =',v,'T = ',T)
        self.v = v
        self.T = T
        pass_length = len([el.symbol for el in self.structure.species if 'Na' in el.symbol])
        print('============================================================')
        print('Start running kMC ... ')
        print('\nInitial occ_global, prob_list and prob_cum_list')
        print('Starting Equilbrium ...')
        for current_pass in np.arange(equ_pass):
            for this_kmc in np.arange(pass_length):
                event,time_change = self.propose(events)
                self.update(event,events)

        print('Start running kMC ...')
        tracker = Tracker()
        tracker.initialization(self.occ_global,self.structure,self.T,self.v)
        print('Pass\tTime\t\tMSD\t\tD_J\t\tD_tracer\tConductivity\tH_R\t\tf\t\tOccNa(1)\tOccNa(2)')
        for current_pass in np.arange(kmc_pass):
            for this_kmc in np.arange(pass_length):
                event,time_change = self.propose(events)
                tracker.update(event,self.occ_global,time_change)
                self.update(event,events)

            previous_conduct = tracker.summary(comp,current_pass)
            tracker.show_current_info(comp,current_pass)

        tracker.write_results(comp,structure_idx,current_pass,self.occ_global)
    def run_from_database2(self,kmc_pass=1000,equ_pass=1,v=5000000000000,T=298,events="./inputs/events.json",comp=1,structure_idx=1,random_seed=114514,use_numpy_random_kernel=True,verbose=False,**kwargs):
        api=2
        
        if use_numpy_random_kernel==True:
            self.rng=np.random.default_rng(seed=random_seed)
        else:
            self.rng=False
        
        
        print('Simulation condition: v =',v,'T = ',T)
        self.v = v
        self.T = T
        pass_length = len([el.symbol for el in self.structure.species if 'Na' in el.symbol])
        print('============================================================')
        print('Start running kMC ... ')
        print('\nInitial occ_global, prob_list and prob_cum_list')
        print('Starting Equilbrium ...')
        for current_pass in np.arange(equ_pass):
            for this_kmc in np.arange(pass_length):
                event,time_change = self.propose(events,random_seed=random_seed,use_numpy_random_kernel=use_numpy_random_kernel,api=api,rng=self.rng,verbose=verbose)
                self.update(event,events)

        print('Start running kMC ...')
        tracker = Tracker()
        tracker.initialization(self.occ_global,self.structure,self.T,self.v)
        print('Pass\tTime\t\tMSD\t\tD_J\t\tD_tracer\tConductivity\tH_R\t\tf\t\tOccNa(1)\tOccNa(2)')
        for current_pass in np.arange(kmc_pass):
            for this_kmc in np.arange(pass_length):
                event,time_change = self.propose(events,random_seed=random_seed,use_numpy_random_kernel=use_numpy_random_kernel,api=api,rng=self.rng,verbose=verbose)
                tracker.update(event,self.occ_global,time_change)
                self.update(event,events)

            previous_conduct = tracker.summary(comp,current_pass)
            tracker.show_current_info(comp,current_pass)

        tracker.write_results(comp,structure_idx,current_pass,self.occ_global)
        if verbose:
            print("verbose information: kmc.KMC.run_from_database is called. API version 2")
    # def run(self,kmc_pass,equ_pass,v,T,events):
    #     print('Simulation condition: v =',v,'T = ',T)
    #     self.v = v
    #     self.T = T
    #     pass_length = len([el.symbol for el in self.structure.species if 'Na' in el.symbol])
    #     print('============================================================')
    #     print('Start running kMC ... ')
    #     print('\nInitial occ_global, prob_list and prob_cum_list')
    #     print('Starting Equilbrium ...')
    #     for current_pass in np.arange(equ_pass):
    #         for this_kmc in np.arange(pass_length):
    #             event,time_change = self.propose(events)
    #             self.update(event,events)

    #     print('Start running kMC ...')
    #     tracker = Tracker()
    #     tracker.initialization(self.occ_global,self.structure,self.T,self.v)
    #     print('Pass\tTime\t\tMSD\t\tD_J\t\tD_tracer\tConductivity\tH_R\t\tf\t\tOccNa(1)\tOccNa(2)')
    #     for current_pass in np.arange(kmc_pass):
    #         for this_kmc in np.arange(pass_length):
    #             event,time_change = self.propose(events)
    #             tracker.update(event,self.occ_global,time_change)
    #             self.update(event,events)

    #         previous_conduct = tracker.summary(comp,current_pass)
    #         tracker.show_current_info(current_pass)

    #     tracker.write_results(None,None,current_pass,self.occ_global)

    def as_dict(self):
        d = {"@module":self.__class__.__module__,
        "@class": self.__class__.__name__,
        "structure":self.structure.as_dict(),
        "keci":self.keci,
        "empty_cluster":self.empty_cluster,
        "keci_site":self.keci_site,
        "empty_cluster_site":self.empty_cluster_site,
        "occ_global":self.occ_global}
        return d
    
    def to_json(self,fname):
        print('Saving:',fname)
        with open(fname,'w') as fhandle:
            d = self.as_dict()
            jsonStr = json.dumps(d,indent=4,default=convert) # to get rid of errors of int64
            fhandle.write(jsonStr)
    
    @classmethod
    def from_json(self,fname):
        print('Loading:',fname)
        with open(fname,'rb') as fhandle:
            objDict = json.load(fhandle)
        obj = KMC()
        obj.__dict__ = objDict
        print("load complete")
        return obj

def _convert_list(list_to_convert):
    converted_list = List([List(List(j) for j in i ) for i in list_to_convert])
    return converted_list

